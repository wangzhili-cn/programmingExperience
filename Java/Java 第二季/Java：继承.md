---
继承
---  
> 继承概念  
- Java中的继承是单继承。  
1. 继承是类与类之间的一种关系，用来实现代码的复用；  
2. 子类拥有父类的所有属性和方法；但父类中属性和方法的修饰符不能是private  
3. 继承的语法规则是：  
    class 子类 extends 父类  
    eg.  
      class Dog extends Animal{  
    }  
  extends为继承关键字  
  
> 方法重写：  
1. 什么是方法的重写？  
    如果子类对继承父类的方法不满意，是可以重写父类继承的方法的，当调用的时候会优先调用子类的方法。
2. 语法规则：  
a. 返回值类型  
b. 方法名  
c. 参数类型及个数  
  都要与父类继承的方法相同，才叫方法的重写  
  子类会优先调用自己重写的方法  

> 类的初始化顺序  
- 在实例化一个对象时，会先初始化类中的属性，然后才是构造函数。  
- 先初始化父类，然后才会初始化子类  
- 静态的初始化块最先执行，且只会在类加载时执行一次，然后是｛｝默认初始化代码块，->属性->构造方法  

> final关键字  
- final关键字：使用final关键字做标识有“最终的”含义  
- final可以修饰类、方法、属性和变量  
- final修饰类，则该类不能被继承  
- final修饰方法，则该方法不允许被覆盖（重写）  
- final修饰属性，则该类的属性不会进行隐式的初始化（类的初始化属性必须有值）或在 构造方法中赋值  
- final修饰变量，则该变量只能赋一次值，即变为常量  

> super关键字  
- 在子类中调用父类的属性或方法  
1. 在子类构造方法中要调用父类的构造方法，用“super(参数列表)”的方式调用，参数不是必须的。  
    同时还要注意的一点是：“super(参数列表)”这条语句只能用在子类构造方法体中的第一行。  
2. 当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，  
    用“super.成员变量名”来引用父类成员变量。当然，如果父类的成员变量没有被覆盖，也可以用“super.成员变量名”  
    来引用父类成员变量，不过这是不必要的。  
3. 当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（但方法体可以不同），  
    此时，用“super.方法名(参数列表)”的方式访问父类的方法  
4. 如果子类的构造方法中既没有显示调用父类的构造方法，父类又没有无参的构造方法，则编译就会报错。  

> Object类  
- Object类是所有类的父类,如果一个类没有使用extends关键字明确标识继承另外一个类,那么这个类默认继承Object类,  
  且Object类中的方法适合所有子类  
- 1.toString()方法
在Object类里面定义toString()方法的时候返回的对象的哈希code码(对象地址字符串)  
如果我们在代码里面直接输出一个对象,会输出这个对象在内存中的地址,我们把它称为哈希码,  
哈希码是通过哈希算法生成的一个字符串用来唯一区分对象的  
- 可以通过重写toString()方法表示出对象的属性  
(我们经常在输出对象的时候希望得到子类的属性值,那么我们就要重写从父类继承来的toString()方法,  
eclipse中右键菜单栏-源码source-生成generate toString(),他就会根据我们对象的属性帮我们  
生成一个toString()方法来输出属性值)  
- 2.getClass()可以得到一个类对象,当我们new的时候得到的是一个类的对象如果对象调用getClass()
方法我们得到的是类对象,类对象描述的是类的代码信息(类的代码信息:  
这个类有哪些属性\它是什么类型\变量名是什么\它有哪些方法\方法名是什么\方法里面的代码是什么;  
而类的对象关注的是对象的属性值的信息或者说这个对象的数据信息)  

> Object类2  
equals（）----返回值是布尔类型  
比较的是对象的引用是否指向同一块内存地址-------对象实例化时，即给对象分配内存空间  
使用方法如：dog.equals(dog2);  
如果是两个对象，但想判断两个对象的属性是否相同，则重写equals（）方法  
1.地址是否相同----if (this == obj)  
2.对象是否为空----if (obj == null)  
3.getClass（）可以得到类对象，判断类型是否一样-----if (getClass() != obj.getClass())  
new出来的是类的对象，关注的是类的属性的具体的数据；  
类对象是类的代码信息，关注的是类有什么属性和方法  
4.属性值是否一样----if (age != other.age)  
