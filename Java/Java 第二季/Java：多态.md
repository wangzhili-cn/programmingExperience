---
多态
---  
> 多态概念  
对象的多种形态,继承是多态的基础。  
1. 引用的多态：父类的引用可以指向本类的对象，也可以指向子类的对象。不能使用一个子类的引用指向父类的对象。  
Animal dog = new Dog();//OK    Dog dog=new Animal();//error  
2. 方法的多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法。  
子类独有的方法，无多态特性。  

> 多态中引用类型的转换  
引用类型转换：  
1. 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。  
如：Dog dog=new Dog();Animal animal=dog;//正确，自动类型提升，向上类型转换  
2. 向下类型转换（强制类型转换），是大类型到小类型的转换（存在风险，溢出）  
如：Dog dog1=(Dog)animal;//向下类型转换  
3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。如：  
Dog dog=new Dog();  
Animal animal=dog;  
Cat cat=(Cat)animal;//编译时不会出错（按Cat类型进行编译），但运行时会报错，  
因为它开辟的是Dog类型的空间，而（无法将引用类型进行转换）无法将dog对象转换成Cat类型，  
并且此方法对程序的安全性有影响。此时应该利用instanceof和if语句结合使用，进行验证，  
以保证程序的安全性，如：  
if(animal instanceof Cat){//判断animal类中是否包含Cat类型的元素，  
若包含则进行转换，instanceof返回值为布尔类型  
Cat cat=(Cat)animal;}else{  
System.out.println("无法进行类型转换");}  

> abstract抽象类  
1. 抽象类的作用：  
           限制规定子类必须实现某些方法，但不关注细节。  
           使用规则：  
              a. 使用abstract定义抽象类  
              b. abstract定义抽象方法，只有声明，不需要把它实现。  
              c. 包含抽象方法的类都是抽象类。  
              d. 抽象类中可以包含普通的方法，也可以没有抽象方法。  
              e. 抽象类不能直接创建，可以定义引用变量。  
 2. 抽象方法没有方法体，就用分号结束。  
 3. 抽象类：重在抽，抽取约束的作用。子类会自动继承抽象中的方法。  
 abstract关键字
应用场景：  
   a、在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。  
   b、从多个具有相同特征的类中抽出一抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。  
使用规则：  
   a、abstract定义抽象类  
   b、abstract定义抽象方法，只有声明，不需要实现  
   c、包含抽象方法的类是抽象类  
   d、抽象类中可以包含普通的方法，也可以没有抽象方法  
   e、抽象类不能直接创建，可以定义引用变量  
 
 > 接口  
1. 接口定义：  
           定义接口不再使用class关键字，而是使用interface关键字  
2. 接口定义的基本语法：  
           [修饰符]interface 接口名[extends 父接口1，父接口2....]  
           {  
           零个到多个常量定义...  
           零个到多个抽象方法的定义  
           }  
           接口就是用来被继承、被实现的，修饰符一般建议用 public  
           注意：不能使用 private和protected 修饰接口。  
           接口定义时，一定有abstract关键字，自己没写系统也会加上，通常不写；  
           接口中的属性都是常量（public final static修饰符）；方法都是抽象方法（public abstract修饰）。  

3. 使用接口：  
  一个类可以实现一个或多个接口，实现接口使用implements关键字。  
  Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口可以作补充  
  继承父类实现接口的语法为：  
  [修饰符]class 类名 extends 父类 implements 接口1，接口2...{  
  类体部分  //如果继承了抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法。  
  }  
4. 实现匿名内部类  
           接口还会与匿名内部类。。。没有名字的内部类，多用于实现而不关注类的名字。。  
           Interface i=new interface(){public void method(){  }};  
- 接口中没有构造方法，不能直接实例化，如果要实例化，抽象类引用必须指向实现所有抽象方法的子类对象，  
- 抽象类中有构造方法，但是也不能直接实例化，如果要实例化，接口引用必须指向实现所有接口方法的类对象  

5. UML建模工具  
- 用例图（The Use Case Diagram）  
- 用例图能够以可视化的方式，表达系统如何满足所收集的业务规则，以及特定的用户需求等信息。  
- UML概念：  
- Unified Modeling Language(UML)  
- 又称统一建模语言或标准建模语言  
- 是一个支持模型化和软件系统开发的图形化语言  
- Visio/Rational Rose/PowerDesign三种建模工具应用广泛  

> 一些说明  
1. 语法层面上的区别  
　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；  
　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；  
　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；  
　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。  
2. 设计层面上的区别：  
　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后Airplane和Bird分别根据自己的需要实现Fly这个接口。然后至于有不同种类的飞机，比如战斗机、民用飞机等直接继承Airplane即可，对于鸟也是类似的，不同种类的鸟直接继承Bird类即可。从这里可以看出，继承是一个 "是不是"的关系，而 接口 实现则是 "有没有"的关系。如果一个类继承了某个抽象类，则子类必定是抽象类的种类，而接口实现则是有没有、具备不具备的关系，比如鸟是否能飞（或者是否具备飞行这个特点），能飞行则可以实现这个接口，不能飞行就不实现这个接口。  
　　2）设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。而接口是一种行为规范，它是一种辐射式设计。什么是模板式设计？最简单例子，大家都用过ppt里面的模板，如果用模板A设计了ppt B和ppt C，ppt B和ppt C公共的部分就是模板A了，如果它们的公共部分需要改动，则只需要改动模板A就可以了，不需要重新对ppt B和ppt C进行改动。而辐射式设计，比如某个电梯都装了某种报警器，一旦要更新报警器，就必须全部更新。也就是说对于抽象类，如果需要添加新的方法，可以直接在抽象类中添加具体的实现，子类可以不进行变更；而对于接口则不行，如果接口进行了变更，则所有实现这个接口的类都必须进行相应的改动。  
  
