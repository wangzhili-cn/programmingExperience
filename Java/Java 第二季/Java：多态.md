---
多态
---  
> 多态概念  
对象的多种形态,继承是多态的基础。  
1. 引用的多态：父类的引用可以指向本类的对象，也可以指向子类的对象。不能使用一个子类的引用指向父类的对象。  
Animal dog = new Dog();//OK    Dog dog=new Animal();//error  
2. 方法的多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法。  
子类独有的方法，无多态特性。  

> 多态中引用类型的转换  
引用类型转换：  
1. 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。  
如：Dog dog=new Dog();Animal animal=dog;//正确，自动类型提升，向上类型转换  
2. 向下类型转换（强制类型转换），是大类型到小类型的转换（存在风险，溢出）  
如：Dog dog1=(Dog)animal;//向下类型转换  
3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。如：  
Dog dog=new Dog();  
Animal animal=dog;  
Cat cat=(Cat)animal;//编译时不会出错（按Cat类型进行编译），但运行时会报错，  
因为它开辟的是Dog类型的空间，而（无法将引用类型进行转换）无法将dog对象转换成Cat类型，  
并且此方法对程序的安全性有影响。此时应该利用instanceof和if语句结合使用，进行验证，  
以保证程序的安全性，如：  
if(animal instanceof Cat){//判断animal类中是否包含Cat类型的元素，  
若包含则进行转换，instanceof返回值为布尔类型  
Cat cat=(Cat)animal;}else{  
System.out.println("无法进行类型转换");}  

> abstract抽象类  
1. 抽象类的作用：  
           限制规定子类必须实现某些方法，但不关注细节。  
           使用规则：  
              a. 使用abstract定义抽象类  
              b. abstract定义抽象方法，只有声明，不需要把它实现。  
              c. 包含抽象方法的类都是抽象类。  
              d. 抽象类中可以包含普通的方法，也可以没有抽象方法。  
              e. 抽象类不能直接创建，可以定义引用变量。  
 2. 抽象方法没有方法体，就用分号结束。  
 3. 抽象类：重在抽，抽取约束的作用。子类会自动继承抽象中的方法。  
 abstract关键字
应用场景：  
   a、在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。  
   b、从多个具有相同特征的类中抽出一抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。  
使用规则：  
   a、abstract定义抽象类  
   b、abstract定义抽象方法，只有声明，不需要实现  
   c、包含抽象方法的类是抽象类  
   d、抽象类中可以包含普通的方法，也可以没有抽象方法  
   e、抽象类不能直接创建，可以定义引用变量  
 
 > 接口  
1. 接口定义：  
           定义接口不再使用class关键字，而是使用interface关键字  
2. 接口定义的基本语法：  
           [修饰符]interface 接口名[extends 父接口1，父接口2....]  
           {  
           零个到多个常量定义...  
           零个到多个抽象方法的定义  
           }  
           接口就是用来被继承、被实现的，修饰符一般建议用 public  
           注意：不能使用 private和protected 修饰接口。  
           接口定义时，一定有abstract关键字，自己没写系统也会加上，通常不写；  
           接口中的属性都是常量（public final static修饰符）；方法都是抽象方法（public abstract修饰）。  

3. 使用接口：  
  一个类可以实现一个或多个接口，实现接口使用implements关键字。  
  Java中一个类只能继承一个父类，是不够灵活的，通过实现多个接口可以作补充  
  继承父类实现接口的语法为：  
  [修饰符]class 类名 extends 父类 implements 接口1，接口2...{  
  类体部分  //如果继承了抽象类，需要实现继承的抽象方法；要实现接口中的抽象方法。  
  }  
4. 实现匿名内部类  
           接口还会与匿名内部类。。。没有名字的内部类，多用于实现而不关注类的名字。。  
           Interface i=new interface(){public void method(){  }};  
- 接口中没有构造方法，不能直接实例化，如果要实例化，抽象类引用必须指向实现所有抽象方法的子类对象，  
- 抽象类中有构造方法，但是也不能直接实例化，如果要实例化，接口引用必须指向实现所有接口方法的类对象  
