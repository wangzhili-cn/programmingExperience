---
多态
---  
> 多态概念  
对象的多种形态,继承是多态的基础。  
1. 引用的多态：父类的引用可以指向本类的对象，也可以指向子类的对象。不能使用一个子类的引用指向父类的对象。  
Animal dog = new Dog();//OK    Dog dog=new Animal();//error  
2. 方法的多态：创建本类对象时，调用的方法为本类方法；创建子类对象时，调用的方法为子类重写的方法或者继承的方法。  
子类独有的方法，无多态特性。  

> 多态中引用类型的转换  
引用类型转换：  
1. 向上类型转换（隐式/自动类型转换），是小类型到大类型的转换。  
如：Dog dog=new Dog();Animal animal=dog;//正确，自动类型提升，向上类型转换  
2. 向下类型转换（强制类型转换），是大类型到小类型的转换（存在风险，溢出）  
如：Dog dog1=(Dog)animal;//向下类型转换  
3. instanceof运算符，来解决引用对象的类型，避免类型转换的安全性问题。如：  
Dog dog=new Dog();  
Animal animal=dog;  
Cat cat=(Cat)animal;//编译时不会出错（按Cat类型进行编译），但运行时会报错，  
因为它开辟的是Dog类型的空间，而（无法将引用类型进行转换）无法将dog对象转换成Cat类型，  
并且此方法对程序的安全性有影响。此时应该利用instanceof和if语句结合使用，进行验证，  
以保证程序的安全性，如：  
if(animal instanceof Cat){//判断animal类中是否包含Cat类型的元素，  
若包含则进行转换，instanceof返回值为布尔类型  
Cat cat=(Cat)animal;}else{  
System.out.println("无法进行类型转换");}  

> abstract抽象类  
1. 抽象类的作用：  
           限制规定子类必须实现某些方法，但不关注细节。  
           使用规则：  
              a. 使用abstract定义抽象类  
              b. abstract定义抽象方法，只有声明，不需要把它实现。  
              c. 包含抽象方法的类都是抽象类。  
              d. 抽象类中可以包含普通的方法，也可以没有抽象方法。  
              e. 抽象类不能直接创建，可以定义引用变量。  
 2. 抽象方法没有方法体，就用分号结束。  
 3. 抽象类：重在抽，抽取约束的作用。子类会自动继承抽象中的方法。  
 abstract关键字
应用场景：  
   a、在某些情况下，某个父类只是知道其子类应该包含怎样的方法，但无法准确知道这些子类如何实现这些方法。  
   b、从多个具有相同特征的类中抽出一抽象类，以这个抽象类作为子类的模板，从而避免了子类设计的随意性。  
使用规则：  
   a、abstract定义抽象类  
   b、abstract定义抽象方法，只有声明，不需要实现  
   c、包含抽象方法的类是抽象类  
   d、抽象类中可以包含普通的方法，也可以没有抽象方法  
   e、抽象类不能直接创建，可以定义引用变量  
 
